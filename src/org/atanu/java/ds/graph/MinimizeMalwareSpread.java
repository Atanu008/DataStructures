package org.atanu.java.ds.graph;

import java.util.Arrays;

//https://leetcode.com/problems/minimize-malware-spread/description/
//Leetcode 924

// Explanation : https://leetcode.com/problems/minimize-malware-spread/solutions/320624/java-unionfind-with-explanation/?orderBy=most_votes
// Video : https://www.youtube.com/watch?v=8__sEBHzC00&t=256s (Cab refer)
public class MinimizeMalwareSpread {

    public int minMalwareSpread(int[][] graph, int[] initial) {

        int n = graph.length;
        UnionFindPathCompressionUnionBySize unionFind = new UnionFindPathCompressionUnionBySize(n);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(i != j && graph[i][j] == 1){
                    unionFind.union(i, j);
                }
            }
        }

        int[] parent = unionFind.getParent();
        int[] size = unionFind.getSize();

        int[] infected = new int[n];

        for(int i : initial){
            int rootOfInfected = unionFind.find(i);
            // This will count the nomber of infected in a group/connected componenet
            // Suppose 3 and 8 are infected and both of their parent is 2 then we are incrementing 2's count twice
            infected[rootOfInfected]++;
        }

        Arrays.sort(initial); // Sort because of this requirement f multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

        //if more than 1 infections to all components, select smallest idx from any components...1
        //if only one infection, select larger size of components and it's index should be smallest
        int maxSize = 0;
        int ans = initial[0];
        //System.out.println(Arrays.toString(infected));

        for(int i : initial){

            int rootInfected = unionFind.find(i);
            int infectedCount = infected[rootInfected];

            if(infectedCount == 1 && size[rootInfected] > maxSize){
                ans = i;
                maxSize = size[rootInfected];
            }
        }
        return ans;
    }

    static class UnionFindPathCompressionUnionBySize {

        int[] root;
        int[] size;

        public UnionFindPathCompressionUnionBySize(int n){
            root = new int[n];
            size = new int[n];

            for(int i = 0; i < n; i++){
                root[i] = i;
                size[i] = 1; // The initial "size" of each vertex is 1, because each of them is having one size initially
            }
        }

        public int find(int x){

            if(root[x] == x){
                return x;
            }
            return root[x] = find(root[x]); // path compression
        }

        public void union(int x, int y) {

            int rootX = find(x);
            int rootY = find(y);

            if(size[rootX] > size[rootY]){
                root[rootY] = rootX;
                size[rootX] += size[rootY];
            }
            else{ // Dont need else if as this will cover both  < and == . In both cases we are making rootY as parent
                root[rootX] = rootY;
                size[rootY] += size[rootX];
            }
        }

        public int[] getParent(){
            return root;
        }

        public int[] getSize(){
            return size;
        }
    }
}
